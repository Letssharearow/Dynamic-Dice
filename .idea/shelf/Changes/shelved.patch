Index: app/src/main/java/com/example/dynamicdiceprototype/composables/LandingPage.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.dynamicdiceprototype.composables\r\n\r\nimport android.util.Log\r\nimport androidx.compose.animation.AnimatedVisibility\r\nimport androidx.compose.foundation.layout.Arrangement\r\nimport androidx.compose.foundation.layout.Column\r\nimport androidx.compose.foundation.layout.Row\r\nimport androidx.compose.foundation.layout.fillMaxSize\r\nimport androidx.compose.foundation.layout.fillMaxWidth\r\nimport androidx.compose.foundation.layout.padding\r\nimport androidx.compose.foundation.layout.wrapContentSize\r\nimport androidx.compose.material3.CircularProgressIndicator\r\nimport androidx.compose.material3.Text\r\nimport androidx.compose.runtime.Composable\r\nimport androidx.compose.runtime.DisposableEffect\r\nimport androidx.compose.runtime.getValue\r\nimport androidx.compose.ui.Alignment\r\nimport androidx.compose.ui.Modifier\r\nimport androidx.compose.ui.platform.LocalLifecycleOwner\r\nimport androidx.compose.ui.tooling.preview.Preview\r\nimport androidx.compose.ui.unit.dp\r\nimport androidx.lifecycle.Lifecycle\r\nimport androidx.lifecycle.LifecycleEventObserver\r\nimport com.example.dynamicdiceprototype.data.Dice\r\nimport com.example.dynamicdiceprototype.data.Face\r\nimport com.example.dynamicdiceprototype.services.DiceViewModel\r\nimport com.example.dynamicdiceprototype.services.TAG\r\nimport com.example.dynamicdiceprototype.services.getDices\r\nimport com.example.dynamicdiceprototype.ui.theme.DynamicDicePrototypeTheme\r\n\r\n@Composable\r\nfun LifecycleAwareComponent(onClose: () -> Unit) {\r\n  val lifecycleOwner = LocalLifecycleOwner.current\r\n\r\n  DisposableEffect(lifecycleOwner) {\r\n    val observer = LifecycleEventObserver { _, event ->\r\n      if (event == Lifecycle.Event.ON_STOP) {\r\n        // App is being closed, save data here\r\n        onClose()\r\n      }\r\n    }\r\n\r\n    // Add the observer to the lifecycle\r\n    lifecycleOwner.lifecycle.addObserver(observer)\r\n\r\n    // When the effect leaves the Composition, remove the observer\r\n    onDispose { lifecycleOwner.lifecycle.removeObserver(observer) }\r\n  }\r\n\r\n  // Your composable content goes here\r\n}\r\n\r\n@Composable\r\nfun LandingPage(\r\n    dices: List<Dice>,\r\n    states: List<Face>,\r\n    isLoading: Boolean,\r\n    onRollClicked: () -> Unit,\r\n    onClose: () -> Unit,\r\n    modifier: Modifier = Modifier,\r\n    viewModel: DiceViewModel? = null\r\n) {\r\n  Log.d(TAG, \"Recompose LandingPage ${dices.size}\")\r\n\r\n  val lifecycleOwner = LocalLifecycleOwner.current\r\n  DisposableEffect(lifecycleOwner) {\r\n    val observer = LifecycleEventObserver { _, event ->\r\n      if (event == Lifecycle.Event.ON_STOP) {\r\n        onClose()\r\n      }\r\n      if (event == Lifecycle.Event.ON_PAUSE) {\r\n        onClose()\r\n      }\r\n      if (event == Lifecycle.Event.ON_DESTROY) {\r\n        onClose()\r\n      }\r\n    }\r\n    lifecycleOwner.lifecycle.addObserver(observer)\r\n\r\n    // When the effect leaves the Composition, remove the observer\r\n    onDispose { lifecycleOwner.lifecycle.removeObserver(observer) }\r\n  }\r\n\r\n  Column(\r\n      verticalArrangement = Arrangement.SpaceBetween,\r\n      horizontalAlignment = Alignment.CenterHorizontally,\r\n      modifier = modifier.fillMaxSize()) {\r\n        Column(verticalArrangement = Arrangement.Center, modifier = Modifier.weight(1f)) {\r\n          AnimatedVisibility(visible = !isLoading) {\r\n            DiceBundle(dices = dices, states = states, viewModel = viewModel)\r\n          }\r\n          AnimatedVisibility(visible = isLoading) {\r\n            CircularProgressIndicator(modifier = Modifier.wrapContentSize(align = Alignment.Center))\r\n          }\r\n        }\r\n        Row(\r\n            horizontalArrangement = Arrangement.SpaceAround,\r\n            modifier = Modifier.fillMaxWidth(),\r\n            verticalAlignment = Alignment.CenterVertically) {\r\n              Text(text = \"Sum: ${viewModel?.currentSum}\")\r\n              DiceButtonM3(\r\n                  onRollClicked = onRollClicked, modifier = Modifier.padding(vertical = 16.dp))\r\n              Text(text = \"Rolls: ${viewModel?.countRolls}\")\r\n            }\r\n      }\r\n}\r\n\r\n@Preview(showBackground = true)\r\n@Composable\r\nprivate fun prev() {\r\n  DynamicDicePrototypeTheme {\r\n    LandingPage(\r\n        dices = getDices(5),\r\n        isLoading = false,\r\n        states = listOf(),\r\n        onRollClicked = { /*TODO*/ },\r\n        onClose = {})\r\n  }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/dynamicdiceprototype/composables/LandingPage.kt b/app/src/main/java/com/example/dynamicdiceprototype/composables/LandingPage.kt
--- a/app/src/main/java/com/example/dynamicdiceprototype/composables/LandingPage.kt	(revision b8327c333242e775975a33bf340b097a48ce5482)
+++ b/app/src/main/java/com/example/dynamicdiceprototype/composables/LandingPage.kt	(date 1723381872779)
@@ -2,6 +2,7 @@
 
 import android.util.Log
 import androidx.compose.animation.AnimatedVisibility
+import androidx.compose.foundation.background
 import androidx.compose.foundation.layout.Arrangement
 import androidx.compose.foundation.layout.Column
 import androidx.compose.foundation.layout.Row
@@ -10,13 +11,17 @@
 import androidx.compose.foundation.layout.padding
 import androidx.compose.foundation.layout.wrapContentSize
 import androidx.compose.material3.CircularProgressIndicator
+import androidx.compose.material3.MaterialTheme
 import androidx.compose.material3.Text
 import androidx.compose.runtime.Composable
 import androidx.compose.runtime.DisposableEffect
 import androidx.compose.runtime.getValue
 import androidx.compose.ui.Alignment
 import androidx.compose.ui.Modifier
+import androidx.compose.ui.graphics.Color
 import androidx.compose.ui.platform.LocalLifecycleOwner
+import androidx.compose.ui.text.TextStyle
+import androidx.compose.ui.text.font.FontWeight
 import androidx.compose.ui.tooling.preview.Preview
 import androidx.compose.ui.unit.dp
 import androidx.lifecycle.Lifecycle
@@ -95,12 +100,28 @@
         }
         Row(
             horizontalArrangement = Arrangement.SpaceAround,
-            modifier = Modifier.fillMaxWidth(),
+            modifier =
+                Modifier.fillMaxWidth()
+                    .background(
+                        color = MaterialTheme.colorScheme.primaryContainer) // Light gray background
+            ,
             verticalAlignment = Alignment.CenterVertically) {
-              Text(text = "Sum: ${viewModel?.currentSum}")
+              Text(
+                  text = "Sum: ${viewModel?.currentSum}",
+                  style =
+                      TextStyle(
+                          color = Color.DarkGray, // Darker text color
+                          fontWeight = FontWeight.Bold,
+                          fontSize = MaterialTheme.typography.bodyLarge.fontSize))
               DiceButtonM3(
                   onRollClicked = onRollClicked, modifier = Modifier.padding(vertical = 16.dp))
-              Text(text = "Rolls: ${viewModel?.countRolls}")
+              Text(
+                  text = "Rolls: ${viewModel?.countRolls}",
+                  style =
+                      TextStyle(
+                          color = Color.DarkGray, // Darker text color
+                          fontWeight = FontWeight.Bold,
+                          fontSize = MaterialTheme.typography.bodyLarge.fontSize))
             }
       }
 }
Index: app/src/main/java/com/example/dynamicdiceprototype/services/DiceViewModel.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.dynamicdiceprototype.services\r\n\r\nimport android.content.res.Resources\r\nimport android.util.Log\r\nimport androidx.compose.runtime.getValue\r\nimport androidx.compose.runtime.mutableStateOf\r\nimport androidx.compose.runtime.setValue\r\nimport androidx.compose.ui.graphics.Color\r\nimport androidx.datastore.core.DataStore\r\nimport androidx.lifecycle.ViewModel\r\nimport androidx.lifecycle.ViewModelProvider\r\nimport androidx.lifecycle.viewModelScope\r\nimport com.example.dynamicdiceprototype.DTO.ImageDTO\r\nimport com.example.dynamicdiceprototype.DTO.UserDTO\r\nimport com.example.dynamicdiceprototype.DTO.toDice\r\nimport com.example.dynamicdiceprototype.Exceptions.PermittedActionException\r\nimport com.example.dynamicdiceprototype.data.Dice\r\nimport com.example.dynamicdiceprototype.data.DiceGroup\r\nimport com.example.dynamicdiceprototype.data.DiceLockState\r\nimport com.example.dynamicdiceprototype.data.Face\r\nimport com.example.dynamicdiceprototype.data.toDiceDTO\r\nimport com.example.dynamicdiceprototype.services.serializer.DiceDTOMap\r\nimport com.example.dynamicdiceprototype.services.serializer.ImageDTOMap\r\nimport com.example.dynamicdiceprototype.utils.getInitialDiceGroups\r\nimport com.example.dynamicdiceprototype.utils.getInitialDices\r\nimport com.example.dynamicdiceprototype.utils.getInitialImages\r\nimport com.example.dynamicdiceprototype.utils.temp_group_id\r\nimport kotlinx.coroutines.flow.combine\r\nimport kotlinx.coroutines.launch\r\n\r\n// extend ViewModel to survive configuration change (landscape mode)\r\nclass DiceViewModel(\r\n    imageDataStore: DataStore<ImageDTOMap>,\r\n    diceDataStore: DataStore<DiceDTOMap>,\r\n    userDataStore: DataStore<UserDTO>,\r\n    resources: Resources\r\n) : ViewModel() {\r\n\r\n  var countRolls: Int = 0\r\n  var currentSum: Int = 0\r\n\r\n  // dataStore\r\n  private val imagesStore = imageDataStore // TODO make private, updateData should not be public\r\n  private val dicesStore = diceDataStore\r\n  private val userConfigStore = userDataStore\r\n\r\n  private val resourcesForBitmap = resources\r\n\r\n  val firebase = FirebaseDataStore()\r\n  var currentDices by mutableStateOf(listOf<Dice>())\r\n\r\n  var imageMap by mutableStateOf<Map<String, ImageDTO>>(emptyMap())\r\n  var hasLoadedUser by mutableStateOf(false)\r\n\r\n  // create Dice\r\n  var diceInEdit by mutableStateOf<Dice>(Dice()) // TODO make nullable\r\n  var isDiceEditMode by mutableStateOf<Boolean>(false) //\r\n\r\n  // create Dice Group\r\n  var groupInEdit by mutableStateOf<DiceGroup?>(null)\r\n  var isGroupEditMode by mutableStateOf<Boolean>(false)\r\n\r\n  // User Config\r\n  var diceGroups by mutableStateOf<Map<String, DiceGroup>>(emptyMap())\r\n  var dices by mutableStateOf<Map<String, Dice>>(emptyMap())\r\n  var lastDiceGroup by mutableStateOf(\"Red flag or Green flag\")\r\n\r\n  var toastMessageText by mutableStateOf<String?>(null)\r\n\r\n  var selectedImages by mutableStateOf(emptyMap<ImageDTO, Int>())\r\n\r\n  init {\r\n    populatedDicesWithImages()\r\n    collectUserConfig()\r\n  }\r\n\r\n  private fun collectUserConfig() {\r\n    viewModelScope.launch {\r\n      userConfigStore.data.collect {\r\n        Log.d(\r\n            TAG,\r\n            \"ViewModel collectUserConfig flow: groups key ${it.diceGroups.values.map { group -> group.name }}\")\r\n        diceGroups = it.diceGroups\r\n        hasLoadedUser = true\r\n        if (!it.diceGroups.keys.contains(temp_group_id)) {\r\n          initiateImages()\r\n          initiateDices()\r\n          initiateDiceGroups()\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private fun populatedDicesWithImages() {\r\n    viewModelScope.launch {\r\n      combine(\r\n              dicesStore.data,\r\n              imagesStore.data,\r\n          ) { dices, images ->\r\n            // Process the data from both DataStores here\r\n            dices to images // Pair the data for easier access\r\n          }\r\n          .collect { (dicesFlow, imagesFlow) ->\r\n            Log.d(\r\n                TAG,\r\n                \"ViewModel populatedDicesWithImages flow: dices keys ${dicesFlow.dices.keys} images Size: ${imagesFlow.images.keys.size}\")\r\n            dices =\r\n                dicesFlow.dices.mapValues { diceDTOEntry ->\r\n                  diceDTOEntry.value.toDice(diceDTOEntry.key, imagesFlow.images)\r\n                }\r\n            imageMap = imagesFlow.images\r\n          }\r\n    }\r\n  }\r\n\r\n  private fun initiateDices() {\r\n    val initialDices = getInitialDices()\r\n    initialDices.forEach { addDice(it) }\r\n  }\r\n\r\n  private fun initiateImages() {\r\n    val images = getInitialImages(resourcesForBitmap)\r\n    saveImages(images)\r\n  }\r\n\r\n  private fun initiateDiceGroups() {\r\n    val groups = getInitialDiceGroups()\r\n    groups.forEach { saveGroup(it) }\r\n  }\r\n\r\n  private fun generateUniqueName(baseName: String, keys: List<String>): String {\r\n    var uniqueName = baseName\r\n    while (keys.contains(uniqueName)) {\r\n      uniqueName += \"_copy\"\r\n    }\r\n    return uniqueName\r\n  }\r\n\r\n  // Dice\r\n\r\n  // create Dice Flow\r\n\r\n  fun setDiceName(name: String) {\r\n    diceInEdit.name = name\r\n  }\r\n\r\n  fun createNewDice() {\r\n    diceInEdit = Dice(name = \"Change Later\")\r\n    isDiceEditMode = false\r\n  }\r\n\r\n  fun setSelectedFaces(values: Map<ImageDTO, Int>) {\r\n    diceInEdit.faces =\r\n        values.map { entry ->\r\n          Face(\r\n              data = FirebaseDataStore.base64ToBitmap(entry.key.base64String),\r\n              value = entry.value,\r\n              contentDescription =\r\n                  entry.key.contentDescription) // TODO mapper from Face -> ImageDTO and vice versa\r\n        }\r\n  }\r\n\r\n  fun setColor(color: Color) {\r\n    diceInEdit.backgroundColor = color\r\n  }\r\n\r\n  private fun addDice(dice: Dice) {\r\n    viewModelScope.launch {\r\n      dicesStore.updateData {\r\n        val toMutableMap = it.dices.toMutableMap()\r\n        toMutableMap[dice.id] = dice.toDiceDTO()\r\n        it.copy(dices = toMutableMap)\r\n      }\r\n    }\r\n  }\r\n\r\n  fun saveDice() {\r\n    addDice(if (isDiceEditMode) diceInEdit else diceInEdit.copy(id = \"\"))\r\n  }\r\n\r\n  // end create dice\r\n\r\n  // Dice Menu Actions\r\n\r\n  fun removeKeyFromInnerMaps(diceGroups: MutableMap<String, DiceGroup>, keyToRemove: String) {\r\n    diceGroups.keys.forEach { groupKey ->\r\n      diceGroups[groupKey] =\r\n          DiceGroup(\r\n              dices = diceGroups[groupKey]?.dices?.filterKeys { it != keyToRemove } ?: emptyMap(),\r\n              states = diceGroups[groupKey]?.states ?: emptyList())\r\n    }\r\n  }\r\n\r\n  val nonMutableDices = listOf(\"6er\")\r\n\r\n  fun removeDice(dice: Dice) {\r\n    if (nonMutableDices.contains(dice.name))\r\n        throw PermittedActionException(\"Can not make changes to Dice: ${dice.name}\")\r\n    viewModelScope.launch {\r\n      dicesStore.updateData {\r\n        val toMutableMap = it.dices.toMutableMap()\r\n        toMutableMap.remove(dice.id)\r\n        it.copy(dices = toMutableMap)\r\n      }\r\n    }\r\n    viewModelScope.launch {\r\n      userConfigStore.updateData {\r\n        val toMutableMap = it.diceGroups.toMutableMap()\r\n        removeKeyFromInnerMaps(toMutableMap, dice.id)\r\n        it.copy(diceGroups = toMutableMap)\r\n      }\r\n    }\r\n  }\r\n\r\n  fun editDice(dice: Dice) {\r\n    if (nonMutableDices.contains(dice.name))\r\n        throw PermittedActionException(\"Can not make changes to Dice: ${dice.name}\")\r\n    isDiceEditMode = true\r\n    diceInEdit = dice\r\n  }\r\n\r\n  fun duplicateDice(it: Dice) {\r\n    val newDice = it.copy(id = \"\", name = it.name.plus(\"_copy\"))\r\n    addDice(newDice)\r\n  }\r\n\r\n  // Dice Menu Actions end\r\n\r\n  fun selectDice(dice: Dice) {\r\n    countRolls = 0\r\n    diceGroups[temp_group_id]?.let { saveGroup(it.copy(dices = mapOf(dice.id to 1))) }\r\n  }\r\n\r\n  // Dice end\r\n\r\n  // Dice Group\r\n  // create Dice Group\r\n  fun createNewGroup() {\r\n    groupInEdit = DiceGroup()\r\n    isGroupEditMode = false\r\n  }\r\n\r\n  fun setGroupInEditDices(name: String, dices: Map<Dice, Int>) {\r\n    groupInEdit =\r\n        groupInEdit?.copy(\r\n            name = name, dices = mapOf(*dices.map { Pair(it.key.id, it.value) }.toTypedArray()))\r\n            ?: DiceGroup(\r\n                name = name,\r\n                dices = mapOf(*dices.map { Pair(it.key.id, it.value) }.toTypedArray()),\r\n            )\r\n  }\r\n\r\n  fun setSelectedStates(states: Map<ImageDTO, Int>) {\r\n    groupInEdit =\r\n        groupInEdit?.let { group -> group.copy(states = states.keys.map { it.contentDescription }) }\r\n  }\r\n\r\n  fun saveGroupInEdit() {\r\n    groupInEdit?.let { saveGroup(it) }\r\n  }\r\n\r\n  fun saveGroup(group: DiceGroup) {\r\n    viewModelScope.launch {\r\n      userConfigStore.updateData { userDTO ->\r\n        val toMutableMap = userDTO.diceGroups.toMutableMap()\r\n        group.let { group -> toMutableMap[group.id] = group }\r\n        userDTO.copy(diceGroups = toMutableMap.mapKeys { it.value.id })\r\n      }\r\n    }\r\n  }\r\n\r\n  // create Dice Group end\r\n  // group Menu Actions\r\n  fun removeGroup(groupId: String) {\r\n    if (groupId == temp_group_id) {\r\n      return\r\n    }\r\n    viewModelScope.launch {\r\n      userConfigStore.updateData {\r\n        val toMutableMap = it.diceGroups.toMutableMap()\r\n        toMutableMap.remove(groupId)\r\n        it.copy(diceGroups = toMutableMap)\r\n      }\r\n    }\r\n  }\r\n\r\n  fun setGroupInEdit(groupId: String) {\r\n    isGroupEditMode = true\r\n    val group = diceGroups[groupId]\r\n    group?.let { group -> groupInEdit = group.copy(dices = group.dices.toMap()) }\r\n  }\r\n\r\n  fun duplicateGroup(groupId: String) {\r\n    val newDiceGroup =\r\n        diceGroups[groupId]?.copy(\r\n            id = \"\",\r\n            name =\r\n                generateUniqueName(\r\n                    baseName = diceGroups[groupId]?.name ?: \"\", diceGroups.values.map { it.name }))\r\n            ?: DiceGroup()\r\n    viewModelScope.launch {\r\n      userConfigStore.updateData {\r\n        val toMutableMap = it.diceGroups.toMutableMap()\r\n        toMutableMap[newDiceGroup.id] = newDiceGroup\r\n        it.copy(diceGroups = toMutableMap)\r\n      }\r\n    }\r\n  }\r\n\r\n  // group Menu Actions end\r\n\r\n  fun saveDiceGroup(group: DiceGroup) {\r\n    val tempGroup = diceGroups[temp_group_id]!!\r\n    saveGroup(group.copy(id = tempGroup.id, name = tempGroup.name))\r\n  }\r\n\r\n  fun selectDiceGroup(groupId: String) {\r\n    countRolls = 0\r\n    if (dices.isEmpty()) {\r\n      return\r\n    }\r\n    diceGroups[groupId]?.dices?.let { diceMap ->\r\n      setNewCurrentDices(diceMap.mapKeys { dices[it.key]!! })\r\n    }\r\n  }\r\n\r\n  // Dice Group end\r\n\r\n  private fun addToCurrentDices(oldState: List<Dice>, dices: Map<Dice, Int>) {\r\n    val newDicesState = oldState.toMutableList()\r\n    dices.forEach { (dice, count) ->\r\n      for (i in 1..count) {\r\n        newDicesState.add(dice.copy(rotation = 0f))\r\n      }\r\n    }\r\n    currentDices = newDicesState\r\n  }\r\n\r\n  // Main Screen actions\r\n  fun setNewCurrentDices(dices: Map<Dice, Int>) {\r\n    addToCurrentDices(emptyList(), dices)\r\n  }\r\n\r\n  fun duplicateToCurrentDices(newDices: Map<Dice, Int>) {\r\n    addToCurrentDices(currentDices, newDices)\r\n  }\r\n\r\n  fun rollSingleDice(dice: Dice) {\r\n    currentDices =\r\n        currentDices.map {\r\n          if (it === dice) {\r\n            it.roll()\r\n          } else it\r\n        }\r\n  }\r\n\r\n  fun lockDice(dice: Dice) {\r\n    currentDices =\r\n        // use Map function to trigger recomposition\r\n        currentDices.map {\r\n          if (it ===\r\n              dice) { // use === to compare references so that dices with same rotation and Id still\r\n            // are different\r\n            // use copy function to trigger recomposition\r\n            if (dice.diceLockState == DiceLockState.UNLOCKED)\r\n                dice.copy(diceLockState = DiceLockState.LOCKED, rotation = 0f)\r\n            else {\r\n              dice.copy(diceLockState = DiceLockState.UNLOCKED, rotation = 0f)\r\n            }\r\n          } else it\r\n        }\r\n  }\r\n\r\n  fun setDiceState(dice: Dice, state: Face?) {\r\n    currentDices =\r\n        currentDices.map {\r\n          if (it === dice) {\r\n            it.copy(state = state)\r\n          } else it\r\n        }\r\n  }\r\n\r\n  fun rollDices() {\r\n    countRolls++\r\n    currentSum = 0\r\n    currentDices =\r\n        currentDices.map { dice ->\r\n          if (dice.diceLockState != DiceLockState.LOCKED) {\r\n            dice.roll().also { currentSum += it.current?.value ?: 0 }\r\n          } else {\r\n            dice\r\n          }\r\n        }\r\n  }\r\n\r\n  fun resetCurrentDices() {\r\n    countRolls = 0\r\n    currentDices = currentDices.map { it.reset() }\r\n  }\r\n\r\n  fun setCurrentDicesState(state: DiceLockState) {\r\n    currentDices = currentDices.map { it.copy(diceLockState = state) }\r\n  }\r\n\r\n  fun saveCurrentDices() {\r\n    val newDices = mutableMapOf<String, Int>()\r\n    currentDices.forEach { newDices[it.id] = newDices[it.id]?.plus(1) ?: 1 }\r\n    diceGroups[temp_group_id]?.let { saveGroup(it.copy(dices = newDices)) }\r\n  }\r\n\r\n  // Main Screen actions end\r\n\r\n  // Firebase Access\r\n  fun getErrorMessage() = firebase.errorMessage\r\n\r\n  fun saveImages(newImages: List<ImageDTO>) {\r\n    viewModelScope.launch {\r\n      imagesStore.updateData { t ->\r\n        val mutableMapState = t.images.toMutableMap()\r\n        newImages.forEach { mutableMapState[it.contentDescription] = it }\r\n        t.copy(images = mutableMapState) // TODO make persistentMap()?\r\n      }\r\n    }\r\n  }\r\n\r\n  // Firebase Access end\r\n  fun changeSelectedImages(images: Map<ImageDTO, Int>) {\r\n    selectedImages = images\r\n  }\r\n\r\n  fun deleteImages(images: Map<ImageDTO, Int>) {\r\n    viewModelScope.launch {\r\n      imagesStore.updateData { t ->\r\n        val mutableMapState = t.images.toMutableMap()\r\n        images.forEach { mutableMapState.remove(it.key.contentDescription) }\r\n        t.copy(images = mutableMapState) // TODO make persistentMap()?\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nclass DiceViewModelFactory(\r\n    private val imageDataStore: DataStore<ImageDTOMap>,\r\n    private val diceDataStore: DataStore<DiceDTOMap>,\r\n    private val userDataStore: DataStore<UserDTO>,\r\n    private val resources: Resources\r\n) : ViewModelProvider.Factory {\r\n\r\n  override fun <T : ViewModel> create(modelClass: Class<T>): T {\r\n    if (modelClass.isAssignableFrom(DiceViewModel::class.java)) {\r\n      @Suppress(\"UNCHECKED_CAST\")\r\n      return DiceViewModel(imageDataStore, diceDataStore, userDataStore, resources) as T\r\n    }\r\n    throw IllegalArgumentException(\"Unknown ViewModel class\")\r\n  }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/dynamicdiceprototype/services/DiceViewModel.kt b/app/src/main/java/com/example/dynamicdiceprototype/services/DiceViewModel.kt
--- a/app/src/main/java/com/example/dynamicdiceprototype/services/DiceViewModel.kt	(revision b8327c333242e775975a33bf340b097a48ce5482)
+++ b/app/src/main/java/com/example/dynamicdiceprototype/services/DiceViewModel.kt	(date 1723375527232)
@@ -320,7 +320,7 @@
       return
     }
     diceGroups[groupId]?.dices?.let { diceMap ->
-      setNewCurrentDices(diceMap.mapKeys { dices[it.key]!! })
+      setNewCurrentDices(diceMap.mapKeys { dices[it.key] ?: Dice() })
     }
   }
 
Index: app/src/main/java/com/example/dynamicdiceprototype/composables/Dice Button.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.dynamicdiceprototype.composables\r\n\r\nimport androidx.compose.animation.core.*\r\nimport androidx.compose.foundation.Image\r\nimport androidx.compose.foundation.background\r\nimport androidx.compose.foundation.layout.Box\r\nimport androidx.compose.foundation.layout.size\r\nimport androidx.compose.foundation.shape.RoundedCornerShape\r\nimport androidx.compose.material3.*\r\nimport androidx.compose.runtime.*\r\nimport androidx.compose.ui.Alignment\r\nimport androidx.compose.ui.Modifier\r\nimport androidx.compose.ui.graphics.graphicsLayer\r\nimport androidx.compose.ui.res.painterResource\r\nimport androidx.compose.ui.unit.dp\r\nimport com.example.dynamicdiceprototype.R\r\n\r\n@Composable\r\nfun DiceButtonM3(onRollClicked: () -> Unit, modifier: Modifier = Modifier) {\r\n  var spinCount by remember { mutableStateOf(0) }\r\n  val rotation by\r\n      animateFloatAsState(\r\n          targetValue = 900f * spinCount,\r\n          animationSpec = tween(durationMillis = 250, easing = FastOutSlowInEasing))\r\n\r\n  // Use Material 3 Button styles\r\n  FilledTonalButton(\r\n      onClick = {\r\n        spinCount++\r\n        onRollClicked()\r\n      },\r\n      shape = RoundedCornerShape(12.dp),\r\n      // Customize colors for your button here\r\n      colors = ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.secondary),\r\n      modifier = modifier) {\r\n        Box(\r\n            contentAlignment = Alignment.Center,\r\n            modifier = Modifier.size(50.dp).background(MaterialTheme.colorScheme.secondary)) {\r\n              Image(\r\n                  painter = painterResource(id = R.drawable.rolling_dices_transparent),\r\n                  contentDescription = \"rolling dices button\",\r\n                  modifier = Modifier.size(100.dp).graphicsLayer { rotationZ = rotation })\r\n            }\r\n      }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/dynamicdiceprototype/composables/Dice Button.kt b/app/src/main/java/com/example/dynamicdiceprototype/composables/Dice Button.kt
--- a/app/src/main/java/com/example/dynamicdiceprototype/composables/Dice Button.kt	(revision b8327c333242e775975a33bf340b097a48ce5482)
+++ b/app/src/main/java/com/example/dynamicdiceprototype/composables/Dice Button.kt	(date 1723381510016)
@@ -12,8 +12,10 @@
 import androidx.compose.ui.Modifier
 import androidx.compose.ui.graphics.graphicsLayer
 import androidx.compose.ui.res.painterResource
+import androidx.compose.ui.tooling.preview.Preview
 import androidx.compose.ui.unit.dp
 import com.example.dynamicdiceprototype.R
+import com.example.dynamicdiceprototype.ui.theme.DynamicDicePrototypeTheme
 
 @Composable
 fun DiceButtonM3(onRollClicked: () -> Unit, modifier: Modifier = Modifier) {
@@ -31,15 +33,27 @@
       },
       shape = RoundedCornerShape(12.dp),
       // Customize colors for your button here
-      colors = ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.secondary),
+      colors = ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.primary),
       modifier = modifier) {
         Box(
             contentAlignment = Alignment.Center,
-            modifier = Modifier.size(50.dp).background(MaterialTheme.colorScheme.secondary)) {
+            modifier = Modifier
+                .size(50.dp)
+                .background(MaterialTheme.colorScheme.primary)) {
               Image(
                   painter = painterResource(id = R.drawable.rolling_dices_transparent),
                   contentDescription = "rolling dices button",
-                  modifier = Modifier.size(100.dp).graphicsLayer { rotationZ = rotation })
+                  modifier = Modifier
+                      .size(100.dp)
+                      .graphicsLayer { rotationZ = rotation })
             }
       }
 }
+
+@Preview
+@Composable
+private fun Preview() {
+    DynamicDicePrototypeTheme {
+        DiceButtonM3(onRollClicked = {})
+    }
+}
\ No newline at end of file
