Index: app/src/main/java/com/example/dynamicdiceprototype/composables/LandingPage.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.dynamicdiceprototype.composables\r\n\r\nimport android.util.Log\r\nimport androidx.compose.animation.AnimatedVisibility\r\nimport androidx.compose.foundation.layout.Arrangement\r\nimport androidx.compose.foundation.layout.Column\r\nimport androidx.compose.foundation.layout.fillMaxSize\r\nimport androidx.compose.foundation.layout.padding\r\nimport androidx.compose.foundation.layout.wrapContentSize\r\nimport androidx.compose.material3.CircularProgressIndicator\r\nimport androidx.compose.runtime.Composable\r\nimport androidx.compose.runtime.getValue\r\nimport androidx.compose.ui.Alignment\r\nimport androidx.compose.ui.Modifier\r\nimport androidx.compose.ui.tooling.preview.Preview\r\nimport androidx.compose.ui.unit.dp\r\nimport com.example.dynamicdiceprototype.data.Dice\r\nimport com.example.dynamicdiceprototype.services.TAG\r\nimport com.example.dynamicdiceprototype.services.getDices\r\nimport com.example.dynamicdiceprototype.ui.theme.DynamicDicePrototypeTheme\r\n\r\n@Composable\r\nfun LandingPage(\r\n    dices: List<Dice>,\r\n    name: String,\r\n    isLoading: Boolean,\r\n    onRollClicked: () -> Unit,\r\n    modifier: Modifier = Modifier\r\n) {\r\n\r\n  Log.d(TAG, \"Recompose LandingPage $name => $dices\")\r\n\r\n  Column(\r\n      verticalArrangement = Arrangement.SpaceBetween,\r\n      horizontalAlignment = Alignment.CenterHorizontally,\r\n      modifier = modifier.fillMaxSize()) {\r\n        AnimatedVisibility(visible = !isLoading) {\r\n          DiceBundle(dices = dices, modifier = Modifier.weight(1f))\r\n        }\r\n        AnimatedVisibility(visible = isLoading, Modifier.weight(1f)) {\r\n          CircularProgressIndicator(modifier = Modifier.wrapContentSize(align = Alignment.Center))\r\n        }\r\n        DiceButtonM3(onRollClicked = onRollClicked, modifier = Modifier.padding(vertical = 16.dp))\r\n      }\r\n}\r\n\r\n@Preview(showBackground = true)\r\n@Composable\r\nprivate fun prev() {\r\n  DynamicDicePrototypeTheme {\r\n    LandingPage(dices = getDices(5), name = \"Test\", isLoading = false, onRollClicked = { /*TODO*/})\r\n  }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/dynamicdiceprototype/composables/LandingPage.kt b/app/src/main/java/com/example/dynamicdiceprototype/composables/LandingPage.kt
--- a/app/src/main/java/com/example/dynamicdiceprototype/composables/LandingPage.kt	(revision 156206f0f25c733123ae8b2f0013991d292df990)
+++ b/app/src/main/java/com/example/dynamicdiceprototype/composables/LandingPage.kt	(date 1715496551703)
@@ -2,6 +2,7 @@
 
 import android.util.Log
 import androidx.compose.animation.AnimatedVisibility
+import androidx.compose.foundation.gestures.detectVerticalDragGestures
 import androidx.compose.foundation.layout.Arrangement
 import androidx.compose.foundation.layout.Column
 import androidx.compose.foundation.layout.fillMaxSize
@@ -12,6 +13,7 @@
 import androidx.compose.runtime.getValue
 import androidx.compose.ui.Alignment
 import androidx.compose.ui.Modifier
+import androidx.compose.ui.input.pointer.pointerInput
 import androidx.compose.ui.tooling.preview.Preview
 import androidx.compose.ui.unit.dp
 import com.example.dynamicdiceprototype.data.Dice
@@ -25,6 +27,7 @@
     name: String,
     isLoading: Boolean,
     onRollClicked: () -> Unit,
+    onSwipeDown: () -> Unit,
     modifier: Modifier = Modifier
 ) {
 
@@ -33,7 +36,17 @@
   Column(
       verticalArrangement = Arrangement.SpaceBetween,
       horizontalAlignment = Alignment.CenterHorizontally,
-      modifier = modifier.fillMaxSize()) {
+      modifier =
+          modifier.fillMaxSize().pointerInput(Unit) {
+            detectVerticalDragGestures { _, dragAmount ->
+              when {
+                dragAmount > 50 -> {
+                  onSwipeDown()
+                }
+                else -> {}
+              }
+            }
+          }) {
         AnimatedVisibility(visible = !isLoading) {
           DiceBundle(dices = dices, modifier = Modifier.weight(1f))
         }
@@ -48,6 +61,6 @@
 @Composable
 private fun prev() {
   DynamicDicePrototypeTheme {
-    LandingPage(dices = getDices(5), name = "Test", isLoading = false, onRollClicked = { /*TODO*/})
+    LandingPage(dices = getDices(5), name = "Test", isLoading = false, onRollClicked = { /*TODO*/}, onSwipeDown = {})
   }
 }
Index: app/src/main/java/com/example/dynamicdiceprototype/services/FirebaseDataStore.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.dynamicdiceprototype.services\r\n\r\nimport android.graphics.Bitmap\r\nimport android.graphics.BitmapFactory\r\nimport android.util.Log\r\nimport androidx.compose.ui.graphics.ImageBitmap\r\nimport androidx.compose.ui.graphics.asImageBitmap\r\nimport com.example.dynamicdiceprototype.DTO.get.DiceGetDTO\r\nimport com.example.dynamicdiceprototype.DTO.get.ImageGetDTO\r\nimport com.example.dynamicdiceprototype.DTO.get.UserGetDTO\r\nimport com.example.dynamicdiceprototype.DTO.set.DiceSetDTO\r\nimport com.example.dynamicdiceprototype.DTO.set.ImageSetDTO\r\nimport com.example.dynamicdiceprototype.DTO.set.UserSetDTO\r\nimport com.example.dynamicdiceprototype.data.Face\r\nimport com.example.dynamicdiceprototype.data.ImageModel\r\nimport com.google.firebase.Firebase\r\nimport com.google.firebase.firestore.firestore\r\nimport java.io.ByteArrayOutputStream\r\nimport kotlin.io.encoding.Base64\r\nimport kotlin.io.encoding.ExperimentalEncodingApi\r\nimport kotlinx.coroutines.Dispatchers\r\nimport kotlinx.coroutines.flow.flow\r\nimport kotlinx.coroutines.tasks.await\r\nimport kotlinx.coroutines.withContext\r\n\r\nconst val TAG = \"MyApp\"\r\nprivate const val IMAGE_COLLECTION_NAME = \"images\"\r\nprivate const val DICES_COLLECTION_NAME = \"dices\"\r\nprivate const val CONFIG_COLLECTION_NAME = \"users\"\r\nconst val local = false\r\n\r\nenum class ImageProperty {\r\n  CONTENT_DESCRIPTION,\r\n  IMAGE_BITMAP\r\n}\r\n\r\nenum class DiceProperty {\r\n  IMAGE_IDS,\r\n  COLOR\r\n}\r\n\r\nenum class UserProperty {\r\n  DICE_GROUPS,\r\n  DICES,\r\n}\r\n\r\nclass FirebaseDataStore {\r\n  private val db = Firebase.firestore\r\n\r\n  val imagesFlow = flow {\r\n    val map = mutableMapOf<String, ImageModel>()\r\n    if (local) {\r\n      emit(mockImages())\r\n      return@flow\r\n    }\r\n    val collectionRef = db.collection(IMAGE_COLLECTION_NAME)\r\n    val documents = collectionRef.get().await()\r\n    for (document in documents) {\r\n      val documentId = document.id\r\n      val documentData = document.data\r\n      Log.d(TAG, \"Firebase fetching data: $documentId => $documentData\")\r\n      val base64String = documentData[ImageProperty.IMAGE_BITMAP.name] as? String ?: continue\r\n      val name = documentData[ImageProperty.CONTENT_DESCRIPTION.name] as? String ?: continue\r\n      map[documentId] =\r\n          ImageModel(imageBitmap = base64ToBitmap(base64String), contentDescription = name)\r\n    }\r\n    Log.d(TAG, \"Firebase all data fetched (keys): ${map.keys}\")\r\n    emit(map)\r\n  }\r\n\r\n  val userFlow = flow {\r\n    val userDTO = fetchUserData(\"juli\")\r\n    emit(userDTO)\r\n  }\r\n\r\n  fun uploadBitmap(key: String, image: ImageSetDTO) {\r\n    val dataMap =\r\n        hashMapOf(\r\n            ImageProperty.IMAGE_BITMAP.name to bitmapToBase64(image.image),\r\n            ImageProperty.CONTENT_DESCRIPTION.name to image.contentDescription)\r\n\r\n    setDocument(key, dataMap, IMAGE_COLLECTION_NAME)\r\n  }\r\n\r\n  fun uploadDice(key: String, dice: DiceSetDTO) {\r\n    val dataMap =\r\n        hashMapOf(\r\n            DiceProperty.IMAGE_IDS.name to dice.images,\r\n            DiceProperty.COLOR.name to dice.backgroundColor,\r\n        )\r\n    setDocument(key, dataMap, DICES_COLLECTION_NAME)\r\n  }\r\n\r\n  fun uploadDices(mapOf: Map<String, DiceSetDTO>) {\r\n    mapOf.forEach { uploadDice(key = it.key, dice = it.value) }\r\n  }\r\n\r\n  fun uploadUserConfig(\r\n      userId: String,\r\n      user: UserSetDTO,\r\n  ) {\r\n    val dataMap =\r\n        hashMapOf(\r\n            UserProperty.DICE_GROUPS.name to user.diceGroups,\r\n            UserProperty.DICES.name to user.dices,\r\n        )\r\n    setDocument(keyName = userId, dataMap = dataMap, collectionName = CONFIG_COLLECTION_NAME)\r\n  }\r\n\r\n  suspend fun fetchUserData(userId: String): UserGetDTO? =\r\n      withContext(Dispatchers.IO) {\r\n        val collectionConfig = db.collection(CONFIG_COLLECTION_NAME)\r\n        try {\r\n          val documentSnapshot = collectionConfig.document(userId).get().await()\r\n          Log.d(TAG, \"Firebase fetchUserData: ${documentSnapshot.id} => ${documentSnapshot.data}\")\r\n          if (documentSnapshot.exists()) {\r\n            val diceGroups =\r\n                documentSnapshot[UserProperty.DICE_GROUPS.name] as? Map<String, Map<String, Int>>\r\n            val dicesName = documentSnapshot[UserProperty.DICES.name] as? List<String>\r\n            val dices = getDicesFromIds(dicesName!!)\r\n            return@withContext UserGetDTO(diceGroups = diceGroups!!, dices = dices)\r\n          }\r\n        } catch (exception: Exception) {\r\n          exception.printStackTrace()\r\n          Log.e(TAG, \"ERROR ${exception.message}\")\r\n        }\r\n        return@withContext null\r\n      }\r\n\r\n  private suspend fun getDicesFromIds(dicesName: List<String>): Map<String, DiceGetDTO> =\r\n      withContext(Dispatchers.IO) {\r\n        val collectionDices = db.collection(DICES_COLLECTION_NAME)\r\n        val dicesList: MutableMap<String, DiceGetDTO> = mutableMapOf()\r\n\r\n        dicesName.forEach { diceName ->\r\n          try {\r\n            val documentSnapshot = collectionDices.document(diceName).get().await()\r\n            Log.d(\r\n                TAG, \"Firebase getDicesFromIds: ${documentSnapshot.id} => ${documentSnapshot.data}\")\r\n            if (documentSnapshot.exists()) {\r\n              val imagesId = documentSnapshot[DiceProperty.IMAGE_IDS.name] as? Map<String, Int>\r\n              val backgroundColor = documentSnapshot[DiceProperty.COLOR.name] as? Number\r\n              Log.d(TAG, \"Firebase getDicesFromIds backgroundColor: $backgroundColor\")\r\n              val images =\r\n                  getImagesFromIds(\r\n                      imagesId!!) // TODO maybe take a better approach to not null assert\r\n              dicesList[diceName] =\r\n                  DiceGetDTO(backgroundColor = backgroundColor!!.toInt(), images = images)\r\n            }\r\n          } catch (exception: Exception) {\r\n            exception.printStackTrace()\r\n            Log.e(TAG, \"ERROR ${exception.message}\")\r\n          }\r\n        }\r\n        Log.d(TAG, \"Firebase dicesList $dicesList\")\r\n        return@withContext dicesList\r\n      }\r\n\r\n  private suspend fun getImagesFromIds(imagesId: Map<String, Int>): List<ImageGetDTO> {\r\n    val collectionDices = db.collection(IMAGE_COLLECTION_NAME)\r\n    val imagesList: MutableList<ImageGetDTO> = mutableListOf()\r\n    imagesId.forEach { (imageId, weight) ->\r\n      collectionDices\r\n          .document(imageId)\r\n          .get()\r\n          .addOnSuccessListener { document ->\r\n            Log.d(TAG, \"Firebase getImagesFromIds: ${document.id} => ${document.data}\")\r\n            if (document.exists()) {\r\n              val imageBase64String = document[ImageProperty.IMAGE_BITMAP.name] as? String\r\n              val contentDescription = document[ImageProperty.CONTENT_DESCRIPTION.name] as? String\r\n              imagesList.add(\r\n                  ImageGetDTO(\r\n                      Face(\r\n                          imageId = imageId,\r\n                          weight = weight,\r\n                          data =\r\n                              ImageModel(\r\n                                  contentDescription = contentDescription!!,\r\n                                  imageBitmap = base64ToBitmap(imageBase64String!!)))))\r\n            }\r\n          }\r\n          .addOnFailureListener { exception ->\r\n            exception.printStackTrace()\r\n            Log.e(TAG, \"ERROR ${exception.message}\")\r\n          }\r\n          .await()\r\n    }\r\n    return imagesList\r\n  }\r\n\r\n  private fun setDocument(\r\n      keyName: String,\r\n      dataMap: Any,\r\n      collectionName:\r\n          String // TODO make a class or something like with the Screen.paths.route and not a\r\n      // string\r\n  ) {\r\n    Log.d(TAG, \"Firebase save this: $keyName => $dataMap\")\r\n    db.collection(collectionName)\r\n        .document(keyName)\r\n        .set(dataMap)\r\n        .addOnSuccessListener { Log.d(TAG, \"Firebase DocumentSnapshot added with ID: $keyName\") }\r\n        .addOnFailureListener { e -> Log.w(TAG, \"Firebase Error adding document\", e) }\r\n  }\r\n\r\n  companion object {\r\n\r\n    @OptIn(ExperimentalEncodingApi::class)\r\n    fun base64ToBitmap(base64String: String): ImageBitmap {\r\n      return try {\r\n        val decodedBytes = Base64.decode(base64String)\r\n        val bitmap = BitmapFactory.decodeByteArray(decodedBytes, 0, decodedBytes.size)\r\n        bitmap.asImageBitmap()\r\n      } catch (e: Exception) {\r\n        e.printStackTrace()\r\n        Log.e(TAG, e.message ?: \"No message\")\r\n        val decodedBytes = Base64.decode(mockImage)\r\n        val bitmap = BitmapFactory.decodeByteArray(decodedBytes, 0, decodedBytes.size)\r\n        bitmap.asImageBitmap()\r\n      }\r\n    }\r\n\r\n    @OptIn(ExperimentalEncodingApi::class)\r\n    fun bitmapToBase64(bitmap: Bitmap): String {\r\n      val byteArrayOutputStream = ByteArrayOutputStream()\r\n      bitmap.compress(Bitmap.CompressFormat.PNG, 100, byteArrayOutputStream)\r\n      val byteArray = byteArrayOutputStream.toByteArray()\r\n      return Base64.encode(byteArray)\r\n    }\r\n  }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/dynamicdiceprototype/services/FirebaseDataStore.kt b/app/src/main/java/com/example/dynamicdiceprototype/services/FirebaseDataStore.kt
--- a/app/src/main/java/com/example/dynamicdiceprototype/services/FirebaseDataStore.kt	(revision 156206f0f25c733123ae8b2f0013991d292df990)
+++ b/app/src/main/java/com/example/dynamicdiceprototype/services/FirebaseDataStore.kt	(date 1715496594501)
@@ -19,6 +19,7 @@
 import kotlin.io.encoding.Base64
 import kotlin.io.encoding.ExperimentalEncodingApi
 import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.flow.Flow
 import kotlinx.coroutines.flow.flow
 import kotlinx.coroutines.tasks.await
 import kotlinx.coroutines.withContext
@@ -47,30 +48,46 @@
 class FirebaseDataStore {
   private val db = Firebase.firestore
 
-  val imagesFlow = flow {
-    val map = mutableMapOf<String, ImageModel>()
-    if (local) {
-      emit(mockImages())
-      return@flow
-    }
-    val collectionRef = db.collection(IMAGE_COLLECTION_NAME)
-    val documents = collectionRef.get().await()
-    for (document in documents) {
-      val documentId = document.id
-      val documentData = document.data
-      Log.d(TAG, "Firebase fetching data: $documentId => $documentData")
-      val base64String = documentData[ImageProperty.IMAGE_BITMAP.name] as? String ?: continue
-      val name = documentData[ImageProperty.CONTENT_DESCRIPTION.name] as? String ?: continue
-      map[documentId] =
-          ImageModel(imageBitmap = base64ToBitmap(base64String), contentDescription = name)
-    }
-    Log.d(TAG, "Firebase all data fetched (keys): ${map.keys}")
-    emit(map)
+  var imagesFlow = setImagesFlow()
+
+  fun setImagesFlow(): Flow<Map<String, ImageModel>> {
+    return flow {
+      val map = mutableMapOf<String, ImageModel>()
+      if (local) {
+        emit(mockImages())
+        return@flow
+      }
+      val collectionRef = db.collection(IMAGE_COLLECTION_NAME)
+      val documents = collectionRef.get().await()
+      for (document in documents) {
+        val documentId = document.id
+        val documentData = document.data
+        Log.d(TAG, "Firebase fetching data: $documentId => $documentData")
+        val base64String = documentData[ImageProperty.IMAGE_BITMAP.name] as? String ?: continue
+        val name = documentData[ImageProperty.CONTENT_DESCRIPTION.name] as? String ?: continue
+        map[documentId] =
+            ImageModel(imageBitmap = base64ToBitmap(base64String), contentDescription = name)
+      }
+      Log.d(TAG, "Firebase all data fetched (keys): ${map.keys}")
+      emit(map)
+    }
   }
+
+  fun startImagesFlow() {
+    imagesFlow = setImagesFlow()
+  }
 
-  val userFlow = flow {
-    val userDTO = fetchUserData("juli")
-    emit(userDTO)
+  var userFlow = setUserFlow()
+
+  fun startUserFlow() {
+    userFlow = setUserFlow()
+  }
+
+  fun setUserFlow(): Flow<UserGetDTO?> {
+    return flow {
+      val userDTO = fetchUserData("juli")
+      emit(userDTO)
+    }
   }
 
   fun uploadBitmap(key: String, image: ImageSetDTO) {
@@ -203,6 +220,11 @@
         .addOnFailureListener { e -> Log.w(TAG, "Firebase Error adding document", e) }
   }
 
+  fun reload() {
+    startImagesFlow()
+    startUserFlow()
+  }
+
   companion object {
 
     @OptIn(ExperimentalEncodingApi::class)
Index: app/src/main/java/com/example/dynamicdiceprototype/services/DiceViewModel.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.dynamicdiceprototype.services\r\n\r\nimport android.graphics.Bitmap\r\nimport androidx.compose.runtime.getValue\r\nimport androidx.compose.runtime.mutableStateMapOf\r\nimport androidx.compose.runtime.mutableStateOf\r\nimport androidx.compose.runtime.setValue\r\nimport androidx.compose.ui.graphics.Color\r\nimport androidx.compose.ui.graphics.asImageBitmap\r\nimport androidx.compose.ui.graphics.toArgb\r\nimport androidx.lifecycle.ViewModel\r\nimport androidx.lifecycle.viewModelScope\r\nimport com.example.dynamicdiceprototype.DTO.set.DiceSetDTO\r\nimport com.example.dynamicdiceprototype.DTO.set.ImageSetDTO\r\nimport com.example.dynamicdiceprototype.DTO.set.UserSetDTO\r\nimport com.example.dynamicdiceprototype.R\r\nimport com.example.dynamicdiceprototype.data.Dice\r\nimport com.example.dynamicdiceprototype.data.DiceState\r\nimport com.example.dynamicdiceprototype.data.Face\r\nimport com.example.dynamicdiceprototype.data.ImageModel\r\nimport kotlinx.coroutines.launch\r\n\r\n// extend ViewModel to survive configuration change (landscape mode)\r\nobject DiceViewModel : ViewModel() {\r\n  val firebase = FirebaseDataStore()\r\n  var currentDices by mutableStateOf(listOf<Dice>()) //\r\n  var imageMap = mutableStateMapOf<String, ImageModel>()\r\n  var collectFlows by mutableStateOf(0)\r\n\r\n  // create Dice\r\n  var newDice by mutableStateOf<Dice>(Dice(name = \"Change Later\"))\r\n  var facesSize by mutableStateOf<Int>(20)\r\n  val diceGroups = mutableStateMapOf<String, Map<String, Int>>()\r\n  var dices = mutableStateMapOf<String, Dice>()\r\n  var lastDiceGroup by mutableStateOf(\"Kniffel\")\r\n\r\n  fun addDice(dice: Dice) {\r\n    dices[dice.name] = dice\r\n    // TODO Store config locally\r\n  }\r\n\r\n  fun mapDiceIdsToImages(images: Map<String, ImageModel>) {\r\n    dices.forEach { it.value.faces.map { face -> face.data = images[face.imageId] } }\r\n    currentDices.forEach { it.faces.map { face -> face.data = images[face.imageId] } }\r\n  }\r\n\r\n  // create Dice Flow\r\n\r\n  fun copyDice(name: String): Dice {\r\n    val diceState = dices[name]\r\n    if (diceState != null) {\r\n      return copyIfNotExists(diceState.copy(name = name + \"_copy\"))\r\n    }\r\n    return Dice(\r\n        faces = listOf()) // TODO Better handling of error, probably throw exception? Or return null\r\n  }\r\n\r\n  fun copyIfNotExists(dice: Dice): Dice {\r\n    return if (dices.contains(dice.name)) copyIfNotExists(dice.copy(name = dice.name + \"_copy\"))\r\n    else dice\r\n  }\r\n\r\n  fun removeDice(dice: Dice) {\r\n    dices.remove(dice.name)\r\n  }\r\n\r\n  fun setStartDice(newDice: Dice) {\r\n    this.newDice = copyDice(newDice.name)\r\n  }\r\n\r\n  fun updateSelectedFaces(faces: Map<String, Face>) {\r\n    newDice = newDice.copy(faces = faces.values.toList())\r\n  }\r\n\r\n  fun updateBackgroundColor(color: Color) {\r\n    newDice = newDice.copy(backgroundColor = color)\r\n  }\r\n\r\n  fun setDiceName(name: String) {\r\n    newDice.name = name\r\n  }\r\n\r\n  fun createNewDice(number: Int) {\r\n    facesSize = number\r\n    newDice = Dice(name = \"Change Later\")\r\n  }\r\n\r\n  fun setSelectedFaces(values: Collection<Face>) {\r\n    newDice.faces = values.toList()\r\n  }\r\n\r\n  fun setColor(color: Color) {\r\n    newDice.backgroundColor = color\r\n  }\r\n\r\n  fun saveDice() {\r\n    addDice(newDice)\r\n  }\r\n  // end create dice\r\n\r\n  fun createDiceGroup(name: String, dices: Map<String, Pair<Dice, Int>>) {\r\n    diceGroups[name] = mapOf(*dices.map { Pair(it.key, it.value.second) }.toTypedArray())\r\n  }\r\n\r\n  init {\r\n    collectFlow()\r\n    collectUser()\r\n  }\r\n\r\n  // Function to update a single dice\r\n  fun lockDice(dice: Dice) {\r\n    currentDices =\r\n        // use Map function to trigger recomposition\r\n        currentDices.map {\r\n          if (it === dice) {\r\n            // use copy function to trigger recomposition\r\n            if (dice.state == DiceState.UNLOCKED) dice.copy(state = DiceState.LOCKED, rotation = 0F)\r\n            else {\r\n              dice.copy(state = DiceState.UNLOCKED, rotation = 0F)\r\n            }\r\n          } else it\r\n        }\r\n  }\r\n\r\n  fun rollDices() {\r\n    currentDices =\r\n        currentDices.map { dice ->\r\n          if (dice.state != DiceState.LOCKED) {\r\n            dice.copy(current = null) // set null to trigger recomposition and roll in Dice class\r\n          } else {\r\n            dice\r\n          }\r\n        }\r\n  }\r\n\r\n  private fun diceMapToList(dices: List<Dice>, images: Map<String, ImageModel>): List<Dice> {\r\n    return dices.map { dice ->\r\n      dice.copy(faces = dice.faces.map { face -> face.copy(data = images[face.imageId]) })\r\n    }\r\n  }\r\n\r\n  private fun collectFlow() {\r\n    viewModelScope.launch {\r\n      firebase.imagesFlow.collect { images ->\r\n        images.forEach { (key, value) -> imageMap[key] = value }\r\n        mapDiceIdsToImages(images)\r\n      }\r\n      collectFlows++\r\n    }\r\n  }\r\n\r\n  private fun collectUser() { // TODO create more flows and collect data simultaneously\r\n    viewModelScope.launch {\r\n      firebase.userFlow.collect { userDTO ->\r\n        userDTO?.dices?.forEach { (key, value) ->\r\n          dices[key] =\r\n              Dice(\r\n                  name = key,\r\n                  faces = value.images.map { it.face },\r\n                  backgroundColor = Color(value.backgroundColor)) // TODO create mapper function?\r\n        }\r\n        userDTO?.diceGroups?.forEach { (key, value) -> diceGroups[key] = value }\r\n        val dicesList = mutableListOf<Dice>()\r\n        diceGroups[lastDiceGroup]?.map {\r\n          for (i in 1..it.value) {\r\n            dicesList.add(dices[it.key] ?: continue)\r\n          }\r\n        }\r\n        currentDices = dicesList\r\n        mapDiceIdsToImages(imageMap)\r\n      }\r\n      collectFlows++\r\n    }\r\n  }\r\n\r\n  fun selectDiceGroup(groupId: String) {\r\n    lastDiceGroup = groupId\r\n    val newDicesState = mutableListOf<Dice>()\r\n    diceGroups[groupId]?.forEach { idAndCount ->\r\n      val diceToAdd = dices[idAndCount.key]\r\n      diceToAdd?.let {\r\n        for (i in 1..idAndCount.value) {\r\n          newDicesState.add(diceToAdd)\r\n        }\r\n      } // TODO better handling for null Dice\r\n    }\r\n    currentDices = newDicesState\r\n  }\r\n\r\n  fun uploadImage(bitmap: Bitmap, name: String) {\r\n    imageMap[name] = ImageModel(contentDescription = name, imageBitmap = bitmap.asImageBitmap())\r\n    firebase.uploadBitmap(name, ImageSetDTO(image = bitmap, contentDescription = name))\r\n  }\r\n\r\n  fun saveUser() {\r\n    firebase.uploadUserConfig(\r\n        \"juli\", UserSetDTO(dices = dices.map { it.key }, diceGroups = diceGroups))\r\n    firebase.uploadDices(\r\n        dices\r\n            .map { (key, value) ->\r\n              key to\r\n                  DiceSetDTO(\r\n                      images = value.faces.map { it.imageId to it.weight }.toMap(),\r\n                      backgroundColor = value.backgroundColor.toArgb())\r\n            }\r\n            .toMap())\r\n  }\r\n}\r\n\r\nfun getFaces(n: Int): List<Face> {\r\n  val list = mutableListOf<Face>()\r\n  for (i in 1..n) {\r\n    list.add(Face(imageId = \"${R.drawable.six_transparent}\"))\r\n  }\r\n  return list\r\n}\r\n\r\nfun getDices(n: Int = 5): List<Dice> {\r\n  val list = mutableListOf<Dice>()\r\n  for (i in 1..n) {\r\n    list.add(\r\n        Dice(\r\n            name = \"6er\",\r\n            faces =\r\n                listOf(\r\n                    Face(imageId = \"${R.drawable.one_transparent}\"),\r\n                    Face(imageId = \"${R.drawable.two_transparent}\"),\r\n                    Face(imageId = \"${R.drawable.three_transparent}\"),\r\n                    Face(imageId = \"${R.drawable.four_transparent}\"),\r\n                    Face(imageId = \"${R.drawable.five_transparent}\"),\r\n                    Face(imageId = \"${R.drawable.six_transparent}\"))))\r\n  }\r\n  return list\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/dynamicdiceprototype/services/DiceViewModel.kt b/app/src/main/java/com/example/dynamicdiceprototype/services/DiceViewModel.kt
--- a/app/src/main/java/com/example/dynamicdiceprototype/services/DiceViewModel.kt	(revision 156206f0f25c733123ae8b2f0013991d292df990)
+++ b/app/src/main/java/com/example/dynamicdiceprototype/services/DiceViewModel.kt	(date 1715496870606)
@@ -205,6 +205,13 @@
             }
             .toMap())
   }
+
+  fun reload() { // TODO only reload what's necessary, rethink collectFlow approach
+    collectFlows = 0
+    firebase.reload()
+    collectFlow()
+    collectUser()
+  }
 }
 
 fun getFaces(n: Int): List<Face> {
Index: app/src/main/java/com/example/dynamicdiceprototype/composables/wrapper/NavGraph.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.dynamicdiceprototype.composables.wrapper\r\n\r\nimport android.util.Log\r\nimport androidx.compose.runtime.Composable\r\nimport androidx.compose.ui.platform.LocalContext\r\nimport androidx.lifecycle.viewmodel.compose.viewModel\r\nimport androidx.navigation.NavHostController\r\nimport androidx.navigation.compose.NavHost\r\nimport androidx.navigation.compose.composable\r\nimport com.example.dynamicdiceprototype.LifecycleAwareComponent\r\nimport com.example.dynamicdiceprototype.Screen\r\nimport com.example.dynamicdiceprototype.composables.LandingPage\r\nimport com.example.dynamicdiceprototype.composables.createdice.CreateDiceNavGraph\r\nimport com.example.dynamicdiceprototype.composables.screens.DiceGroupCreationScreen\r\nimport com.example.dynamicdiceprototype.composables.screens.DiceGroupsScreen\r\nimport com.example.dynamicdiceprototype.composables.screens.TestScreen\r\nimport com.example.dynamicdiceprototype.composables.screens.UploadImageScreen\r\nimport com.example.dynamicdiceprototype.services.DiceViewModel\r\nimport com.example.dynamicdiceprototype.services.HeaderViewModel\r\nimport com.example.dynamicdiceprototype.services.PreferencesService\r\nimport com.example.dynamicdiceprototype.services.TAG\r\n\r\n@Composable\r\nfun NavGraph(navController: NavHostController) {\r\n  val preferencesService: PreferencesService = PreferencesService\r\n  val viewModel: DiceViewModel = viewModel<DiceViewModel>()\r\n  val context = LocalContext.current\r\n  viewModel.lastDiceGroup = preferencesService.loadLastBundle(context)\r\n\r\n  LifecycleAwareComponent { viewModel.saveUser() }\r\n  NavHost(navController, startDestination = Screen.MainScreen.route) {\r\n    composable(route = Screen.TestScreen.route) { TestScreen() }\r\n    composable(route = Screen.MainScreen.route) {\r\n      val headerViewModel = viewModel<HeaderViewModel>()\r\n      val context = LocalContext.current\r\n      PreferencesService.saveLastBundle(context = context, viewModel.lastDiceGroup)\r\n      headerViewModel.changeHeaderText(viewModel.lastDiceGroup)\r\n      LandingPage(\r\n          dices = viewModel.currentDices,\r\n          name = viewModel.lastDiceGroup,\r\n          isLoading = viewModel.collectFlows <= 1,\r\n          onRollClicked = { viewModel.rollDices() })\r\n    }\r\n    composable(route = Screen.CreateDice.route) { CreateDiceNavGraph(viewModel) }\r\n    composable(route = Screen.UploadImage.route) {\r\n      UploadImageScreen(context, { bitmap, name -> viewModel.uploadImage(bitmap, name) })\r\n    }\r\n    composable(route = Screen.DiceGroups.route) {\r\n      DiceGroupsScreen(\r\n          viewModel.diceGroups.keys.toList(),\r\n          { groupId ->\r\n            try {\r\n              viewModel.selectDiceGroup(groupId)\r\n              navController.navigate(Screen.MainScreen.route)\r\n            } catch (e: NullPointerException) {\r\n              Log.e(TAG, \"One Dice is probably not found in the global dices ${e.message}\")\r\n            }\r\n          },\r\n          {})\r\n    }\r\n    composable(route = Screen.CreateDiceGroup.route) {\r\n      DiceGroupCreationScreen(\r\n          dices = viewModel.dices.values.map { Pair(it, 1) },\r\n          onCreateDiceGroup = { name, dices ->\r\n            viewModel.createDiceGroup(name, dices)\r\n            navController.navigate(Screen.DiceGroups.route)\r\n          },\r\n          groupSize = 4,\r\n      )\r\n    }\r\n  }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/dynamicdiceprototype/composables/wrapper/NavGraph.kt b/app/src/main/java/com/example/dynamicdiceprototype/composables/wrapper/NavGraph.kt
--- a/app/src/main/java/com/example/dynamicdiceprototype/composables/wrapper/NavGraph.kt	(revision 156206f0f25c733123ae8b2f0013991d292df990)
+++ b/app/src/main/java/com/example/dynamicdiceprototype/composables/wrapper/NavGraph.kt	(date 1715496570186)
@@ -39,7 +39,8 @@
           dices = viewModel.currentDices,
           name = viewModel.lastDiceGroup,
           isLoading = viewModel.collectFlows <= 1,
-          onRollClicked = { viewModel.rollDices() })
+          onRollClicked = { viewModel.rollDices() },
+          onSwipeDown = {viewModel.reload()})
     }
     composable(route = Screen.CreateDice.route) { CreateDiceNavGraph(viewModel) }
     composable(route = Screen.UploadImage.route) {
